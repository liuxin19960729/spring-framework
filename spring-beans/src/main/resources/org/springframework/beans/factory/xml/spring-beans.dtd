<!--
	Spring XML Beans DTD, version 2.0
	Authors: Rod Johnson, Juergen Hoeller, Alef Arendsen, Colin Sampaleanu, Rob Harrop

	This defines a simple and consistent way of creating a namespace
	of JavaBeans objects, managed by a Spring BeanFactory, read by
	XmlBeanDefinitionReader (with DefaultBeanDefinitionDocumentReader).

	This document type is used by most Spring functionality, including
	web application contexts, which are based on bean factories.

	Each "bean" element in this document defines a JavaBean.
	Typically the bean class is specified, along with JavaBean properties
	and/or constructor arguments.

	A bean instance can be a "singleton" (shared instance) or a "prototype"
	(independent instance). Further scopes can be provided by extended
	bean factories, for example in a web environment.

	References among beans are supported, that is, setting a JavaBean property
	or a constructor argument to refer to another bean in the same factory
	(or an ancestor factory).

	As alternative to bean references, "inner bean definitions" can be used.
	Singleton flags of such inner bean definitions are effectively ignored:
	Inner beans are typically anonymous prototypes.

	There is also support for lists, sets, maps, and java.util.Properties
	as bean property types or constructor argument types.

	For simple purposes, this DTD is sufficient. As of Spring 2.0,
	XSD-based bean definitions are supported as more powerful alternative.

	XML documents that conform to this DTD should declare the following doctype:

	<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
			"https://www.springframework.org/dtd/spring-beans-2.0.dtd">
-->


<!--
	The document root. A document can contain bean definitions only,
	imports only, or a mixture of both (typically with imports first).
<!ELEMENT beans (
	description?,
	(import | alias | bean)*
)>
beans 元素
description 0 or 1
(import | alias | bean)  import | alias | bean  三种类型子元素任意多 0-任意多的个数
-->
<!ELEMENT beans (
	description?,
	(import | alias | bean)*
)>

<!--
	Default values for all bean definitions. Can be overridden at
	the "bean" level. See those attribute definitions for details.
beans 元素 属性默认值
 default-lazy-init (true | false) "false"  default false  (true | false)  枚举类型

  default-init-method CDATA #IMPLIED 不是必须的  CDATA character data
  default-destroy-method CDATA #IMPLIED 不是必须的  CDATA character data
-->
<!ATTLIST beans default-lazy-init (true | false) "false">
<!ATTLIST beans default-merge (true | false) "false">
<!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) "no">
<!ATTLIST beans default-init-method CDATA #IMPLIED>
<!ATTLIST beans default-destroy-method CDATA #IMPLIED>

<!--
	Element containing informative text describing the purpose of the enclosing
	element. Always optional.
	Used primarily for user documentation of XML bean definition documents.
	<!ELEMENT description (#PCDATA)>  PCDATA类型  文档描述信息
-->
<!ELEMENT description (#PCDATA)>


<!--
	Specifies an XML bean definition resource to import.
	<import resource="application.xml"></import> 导入资源
-->
<!ELEMENT import EMPTY>

<!--
	The relative resource location of the XML bean definition file to import,
	for example "myImport.xml" or "includes/myImport.xml" or "../myImport.xml".

 <import>  resource 元素必须写 类型字符串(CDATA)
-->
<!ATTLIST import resource CDATA #REQUIRED>


<!--
	Defines an alias for a bean, which can reside in a different definition file.

  <alias></alias> 对于Bean的别名定义
-->
<!ELEMENT alias EMPTY>

<!--
	The name of the bean to define an alias for.
  name 必须   alias name CDATA #REQUIRED 字符串
-->
<!ATTLIST alias name CDATA #REQUIRED>

<!--
	The alias name to define for the bean.
	bean定义别名
-->
<!ATTLIST alias alias CDATA #REQUIRED>

<!--
	Allows for arbitrary metadata to be attached to a bean definition.
	源数据附属到 beanDefinition
-->
<!ELEMENT meta EMPTY>

<!--
	Specifies the key name of the metadata parameter being defined.
-->
<!ATTLIST meta key CDATA #REQUIRED>

<!--
	Specifies the value of the metadata parameter being defined as a String.
-->
<!ATTLIST meta value CDATA #REQUIRED>

<!--
	Defines a single (usually named) bean.

	A bean definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same bean is explicitly supported.
-->
<!ELEMENT bean (
	description?,
	(meta | constructor-arg | property | lookup-method | replaced-method)*
)>

<!--
	Beans can be identified by an id, to enable reference checking.

	There are constraints on a valid XML id: if you want to reference your bean
	in Java code using a name that's illegal as an XML id, use the optional
	"name" attribute. If neither is given, the bean class name is used as id
	(with an appended counter like "#2" if there is already a bean with that name).
bean 通过id被识别
!ATTLIST bean id ID #IMPLIED  id  ID 唯一 但是不是必须的
-->
<!ATTLIST bean id ID #IMPLIED>

<!--
	Optional. Can be used to create one or more aliases illegal in an id.
	Multiple aliases can be separated by any number of spaces, commas, or
	semi-colons (or indeed any mixture of the three).

!ATTLIST bean name CDATA #IMPLIED name CDATA 不是必须的

-->
<!ATTLIST bean name CDATA #IMPLIED>

<!--
	Each bean definition must specify the fully qualified name of the class,
	except if it serves only as a parent definition for child bean definitions.

ATTLIST bean class CDATA #IMPLIED 字符串 指定全类路径

-->
<!ATTLIST bean class CDATA #IMPLIED>

<!--
	Optionally specify a parent bean definition. //选择指定一个父定义

	Will use the bean class of the parent if none specified, but can
	also override it. In the latter case, the child bean class must be
	compatible with the parent, i.e. accept the parent's property values
	and constructor argument values, if any.

	A child bean definition will inherit constructor argument values,
	property values and method overrides from the parent, with the option
	to add new values. If init method, destroy method, factory bean and/or factory
	method are specified, they will override the corresponding parent settings.

	The remaining settings will always be taken from the child definition:
	depends on, autowire mode, dependency check, scope, lazy init.

使用父设置 如果设置新的参数会覆盖父的参数
-->
<!ATTLIST bean parent CDATA #IMPLIED>

<!--
	The scope of this bean: typically "singleton" (one shared instance,
	which will be returned by all calls to getBean() with the id),
	or "prototype" (independent instance resulting from each call to
	getBean(). Default is "singleton".

	Singletons are most commonly used, and are ideal for multi-threaded
	service objects. Further scopes, such as "request" or "session",
	might be supported by extended bean factories (for example, in a
	web environment).

	Note: This attribute will not be inherited 继承 by child bean definitions.
	Hence, it needs to be specified per concrete(确实 实在) bean definition.

	Inner bean definitions inherit the singleton status of their containing
	bean definition, unless explicitly specified: The inner bean will be a
	singleton if the containing bean is a singleton, and a prototype if
	the containing bean has any other scope.

default singelton 单例
prototype 工厂

web 环境下扩展了
"request" or "session"


-->
<!ATTLIST bean scope CDATA #IMPLIED>

<!--
	Is this bean "abstract", i.e. not meant to be instantiated itself but
	rather just serving as parent for concrete child bean definitions.
	Default is "false". Specify "true" to tell the bean factory to not try to
	instantiate that particular bean in any case.

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per abstract bean definition.

bean  abstract   (true | false) 枚举类型  IMPLIED 可不写 def false

true 就告诉不能实例化改Bean
note: 这并不能够通过子 child bean 进行继承,因此需要指定每个抽象类的bean定义


-->
<!ATTLIST bean abstract (true | false) #IMPLIED>

<!--
	If this bean should be lazily initialized.
	If false, it will get instantiated on startup by bean factories// 气动时创建
	that perform eager initialization of singletons.

	Note: This attribute will not be inherited by child bean definitions.不会被孩子 childbean 继承
	Hence, it needs to be specified per concrete bean definition. 需要具体指明每一BeanDefinition

-->
<!ATTLIST bean lazy-init (true | false | default) "default">

<!--
	Optional attribute controlling whether to "autowire 自动装配" bean properties.
	This is an automagical process in which bean references don't need to be coded
	explicitly in the XML bean definition file(不需要再代码xml bean definition), but Spring works out dependencies.

	There are 5 modes:

	1. "no" 传统spring 默认，bean 引用必须 ref 标明
	The traditional Spring default. No automagical wiring. Bean references
	must be defined in the XML file via the <ref> element. We recommend(劝告)  this
	in most cases as it makes documentation more explicit.在大多数情况下他使文档更加清晰

	2. "byName" 通过名字自动装配, Cat classBean expose(暴露) dog property,会通过寻找名字自动装配
	Autowiring by property name. If a bean of class Cat exposes a dog property,
	Spring will try to set this to the value of the bean "dog" in the current factory.(尝试在当前)
	Spring will try to set this to the value of the bean "dog" in the current factory.(尝试在当前工厂里面去寻找)
	If there is no matching bean by name, nothing special happens.如果没有匹配的名字,则不会发生任何事情

	3. "byType" 通过属性的Type自动装配,如果在当前的工厂有超过一个Type则会发生错误
	Autowiring if there is exactly one bean of the property type in the bean factory.
	If there is more than one, a fatal error is raised, and you can't use byType
	autowiring for that bean. If there is none, nothing special happens.

	4. "constructor"  没有精确的和 construct() 之间参数没有精确的参数类型进行匹配发生错误
	Analogous(相似) to "byType" for constructor arguments. If there isn't exactly one bean
	of the constructor argument type in the bean factory, a fatal error is raised.

	5. "autodetect"  "constructor" or "byType" 自动进行判断
	Chooses "constructor" or "byType" through introspection of the bean class.
	If a default constructor is found, "byType" gets applied.(发现无参构造 启用byType)

	The latter two are similar to PicoContainer and make bean factories simple to
	configure for small namespaces, but doesn't work as well as standard Spring
	behaviour for bigger applications.
    // e. "property" and "constructor-arg" elements 定义的更加清晰
	Note that explicit dependencies, i.e. "property" and "constructor-arg" elements,
	always override autowiring. Autowire behavior can be combined(联合) with dependency
	checking, which will be performed after all autowiring has been completed.(依赖检查早自动装配完成之后执行)

	Note: This attribute will not be inherited by child bean definitions.//属性不被 child 定义
	Hence, it needs to be specified per concrete bean definition.


ATTLIST bean autowire (no | byName | byType | constructor | autodetect | default) "default"
-->
<!ATTLIST bean autowire (no | byName | byType | constructor | autodetect | default) "default">

<!--
	The names of the beans that this bean depends on being initialized.被初始化所依赖的的bean的名称
	The bean factory will guarantee that these beans get initialized before. bean factoy保证 这些bean在获得之前已经初始化
     //note: 依赖通常使用 bean properties 和 constructor arguments 来表示
	Note that dependencies are normally expressed through bean properties or
	constructor arguments. This property should just be necessary for other kinds
	of dependencies like statics (*ugh*) or database preparation on startup.这个属性通常用于其他类型的依赖(例 static)

	Note: This attribute will not be inherited by child bean definitions.//不被child 继承
	Hence, it needs to be specified per concrete bean definition.他需要真实的指导Bean definition

ATTLIST bean depends-on CDATA #IMPLIED 不是必须的

-->
<!ATTLIST bean depends-on CDATA #IMPLIED>

<!--
	Indicates whether or not this bean should be considered when looking
	for matching candidates to satisfy another bean's autowiring requirements.
	Note that this does not affect explicit references by name, which will get
	resolved even if the specified bean is not marked as an autowire candidate.

autowire-candidate(候选人)   byName 自动装配是不允许的

-->
<!ATTLIST bean autowire-candidate (true | false) #IMPLIED>

<!--
	Optional attribute for the name of the custom initialization method
	to invoke after setting bean properties. The method must have no arguments,
	but may throw any exception.

	自定义初始化方法

	init-method 方法  必须没有参数  可能抛出异常
-->
<!ATTLIST bean init-method CDATA #IMPLIED>

<!--
	Optional attribute for the name of the custom destroy method to invoke
	on bean factory shutdown. The method must have no arguments,
	but may throw any exception.

	Note: Only invoked on beans whose lifecycle is under full control
	of the factory - which is always the case for singletons, but not
	guaranteed for any other scope.
	只保证 singleTon 允许执行  ，其他scope不进行保证


-->
<!ATTLIST bean destroy-method CDATA #IMPLIED>

<!--
	Optional attribute specifying the name of a factory method to use to
	create this object. Use constructor-arg elements to specify arguments
	to the factory method, if it takes arguments. Autowiring does not apply
	to factory methods.使用 constructor-arg elements element 启用指定一个 工厂方法

    在bean 标签上  以 class 属性存在    factory-method 是一个静态方法
	If the "class" attribute is present, the factory method will be a static
	method on the class specified by the "class" attribute on this bean
	definition. Often this will be the same class as that of the constructed
	object - for example, when the factory method is used as an alternative(n 可替代的东西)
	to a constructor. However, it may be on a different class. In that case,
	the created object will *not* be of the class specified in the "class"
	attribute. This is analogous to FactoryBean behavior.

	If the "factory-bean" attribute is present, the "class" attribute is not
	used, and the factory method will be an instance method on the object
	returned from a getBean call with the specified bean name. The factory
	bean may be defined as a singleton or a prototype.

	The factory method can have any number of arguments. Autowiring is not
	supported. Use indexed constructor-arg elements in conjunction(接合  连同) with the
	factory-method attribute.

	Setter Injection can be used in conjunction with a factory method.
	Method Injection cannot, as the factory method returns an instance,
	which will be used when the container creates the bean.

factory-method 是在容器中创建bean时使用代替 class 反射创建对象
-->
<!ATTLIST bean factory-method CDATA #IMPLIED>

<!--
	Alternative to class attribute for factory-method usage.
	If this is specified, no class attribute should be used.
	This should be set to the name of a bean in the current or
	ancestor factories that contains the relevant factory method.
	This allows the factory itself to be configured using Dependency
	Injection, and an instance (rather than static) method to be used.

factory-bean 代替 class 对象 的factory-method方法的还用

实例对象的指定 factory-bean=""
允许实例对象的方法(非静态) method-factory =""


-->
<!ATTLIST bean factory-bean CDATA #IMPLIED>

<!--
	Bean definitions can specify zero or more constructor arguments.
	This is an alternative to "autowire constructor".
	Arguments correspond to either a specific index of the constructor argument
	list or are supposed to be matched generically by type.

	Note: A single generic argument value will just be used once, rather than
	potentially matched multiple times (as of Spring 1.1).

	constructor-arg elements are also used in conjunction with the factory-method
	element to construct beans using static or instance factory methods.


constructor-arg 元素
 description  0 || 1 个字元素


-->
<!ELEMENT constructor-arg (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	The constructor-arg tag can have an optional index attribute,
	to specify the exact index in the constructor argument list. Only needed
	to avoid ambiguities, e.g. in case of 2 arguments of the same type.
-->
<!ATTLIST constructor-arg index CDATA #IMPLIED>

<!--
	The constructor-arg tag can have an optional type attribute,
	to specify the exact type of the constructor argument. Only needed
	to avoid ambiguities, e.g. in case of 2 single argument constructors
	that can both be converted from a String.
-->
<!ATTLIST constructor-arg type CDATA #IMPLIED>

<!--
	A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST constructor-arg ref CDATA #IMPLIED>

<!--
	A short-cut alternative to a child element "value".
-->
<!ATTLIST constructor-arg value CDATA #IMPLIED>


<!--
	Bean definitions can have zero or more properties.
	Property elements correspond to JavaBean setter methods exposed
	by the bean classes. Spring supports primitives, references to other
	beans in the same or related factories, lists, maps and properties.
-->
<!ELEMENT property (
	description?, meta*,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	The property name attribute is the name of the JavaBean property.
	This follows JavaBean conventions: a name of "age" would correspond
	to setAge()/optional getAge() methods.
-->
<!ATTLIST property name CDATA #REQUIRED>

<!--
	A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST property ref CDATA #IMPLIED>

<!--
	A short-cut alternative to a child element "value".
-->
<!ATTLIST property value CDATA #IMPLIED>


<!--
	A lookup method causes the IoC container to override the given method and return
	the bean with the name given in the bean attribute. This is a form of Method Injection.
	It's particularly useful as an alternative to implementing the BeanFactoryAware
	interface, in order to be able to make getBean() calls for non-singleton instances
	at runtime. In this case, Method Injection is a less invasive alternative.
-->
<!ELEMENT lookup-method EMPTY>

<!--
	Name of a lookup method. This method should take no arguments.
-->
<!ATTLIST lookup-method name CDATA #IMPLIED>

<!--
	Name of the bean in the current or ancestor factories that the lookup method
	should resolve to. Often this bean will be a prototype, in which case the
	lookup method will return a distinct instance on every invocation. This
	is useful for single-threaded objects.
-->
<!ATTLIST lookup-method bean CDATA #IMPLIED>


<!--
	Similar to the lookup method mechanism, the replaced-method element is used to control
	IoC container method overriding: Method Injection. This mechanism allows the overriding
	of a method with arbitrary code.
-->
<!ELEMENT replaced-method (
	(arg-type)*
)>

<!--
	Name of the method whose implementation should be replaced by the IoC container.
	If this method is not overloaded, there's no need to use arg-type subelements.
	If this method is overloaded, arg-type subelements must be used for all
	override definitions for the method.
-->
<!ATTLIST replaced-method name CDATA #IMPLIED>

<!--
	Bean name of an implementation of the MethodReplacer interface in the current
	or ancestor factories. This may be a singleton or prototype bean. If it's
	a prototype, a new instance will be used for each method replacement.
	Singleton usage is the norm.
-->
<!ATTLIST replaced-method replacer CDATA #IMPLIED>

<!--
	Subelement of replaced-method identifying an argument for a replaced method
	in the event of method overloading.
-->
<!ELEMENT arg-type (#PCDATA)>

<!--
	Specification of the type of an overloaded method argument as a String.
	For convenience, this may be a substring of the FQN. E.g. all the
	following would match "java.lang.String":
	- java.lang.String
	- String
	- Str

	As the number of arguments will be checked also, this convenience can often
	be used to save typing.
-->
<!ATTLIST arg-type match CDATA #IMPLIED>


<!--
	Defines a reference to another bean in this factory or an external
	factory (parent or included factory).
-->
<!ELEMENT ref EMPTY>

<!--
	References must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	to be checked at runtime.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
-->
<!ATTLIST ref bean CDATA #IMPLIED>
<!ATTLIST ref local IDREF #IMPLIED>
<!ATTLIST ref parent CDATA #IMPLIED>


<!--
	Defines a string property value, which must also be the id of another
	bean in this factory or an external factory (parent or included factory).
	While a regular 'value' element could instead be used for the same effect,
	using idref in this case allows validation of local bean ids by the XML
	parser, and name completion by supporting tools.
-->
<!ELEMENT idref EMPTY>

<!--
	ID refs must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	potentially to be checked at runtime by bean factory implementations.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
-->
<!ATTLIST idref bean CDATA #IMPLIED>
<!ATTLIST idref local IDREF #IMPLIED>


<!--
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the required
	type using the JavaBeans PropertyEditor machinery. This makes it
	possible for application developers to write custom PropertyEditor
	implementations that can convert strings to arbitrary target objects.

	Note that this is recommended for simple objects only.
	Configure more complex objects by populating JavaBean
	properties with references to other beans.
-->
<!ELEMENT value (#PCDATA)>

<!--
	The value tag can have an optional type attribute, to specify the
	exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
-->
<!ATTLIST value type CDATA #IMPLIED>

<!--
	Denotes a Java null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special PropertyEditor does so.
-->
<!ELEMENT null (#PCDATA)>


<!--
	A list can contain multiple inner bean, ref, collection, or value elements.
	Java lists are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
	A list can also map to an array type. The necessary conversion
	is automatically performed by the BeanFactory.
-->
<!ELEMENT list (
	(bean | ref | idref | value | null | list | set | map | props)*
)>

<!--
	Enable/disable merging for collections when using parent/child beans.
-->
<!ATTLIST list merge (true | false | default) "default">

<!--
	Specify the default Java type for nested values.
-->
<!ATTLIST list value-type CDATA #IMPLIED>


<!--
	A set can contain multiple inner bean, ref, collection, or value elements.
	Java sets are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
-->
<!ELEMENT set (
	(bean | ref | idref | value | null | list | set | map | props)*
)>

<!--
	Enable/disable merging for collections when using parent/child beans.
-->
<!ATTLIST set merge (true | false | default) "default">

<!--
	Specify the default Java type for nested values.
-->
<!ATTLIST set value-type CDATA #IMPLIED>


<!--
	A Spring map is a mapping from a string key to object.
	Maps may be empty.
-->
<!ELEMENT map (
	(entry)*
)>

<!--
	Enable/disable merging for collections when using parent/child beans.
-->
<!ATTLIST map merge (true | false | default) "default">

<!--
	Specify the default Java type for nested entry keys.
-->
<!ATTLIST map key-type CDATA #IMPLIED>

<!--
	Specify the default Java type for nested entry values.
-->
<!ATTLIST map value-type CDATA #IMPLIED>

<!--
	A map entry can be an inner bean, ref, value, or collection.
	The key of the entry is given by the "key" attribute or child element.
-->
<!ELEMENT entry (
	key?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	Each map element must specify its key as attribute or as child element.
	A key attribute is always a String value.
-->
<!ATTLIST entry key CDATA #IMPLIED>

<!--
	A short-cut alternative to a "key" element with a "ref bean=" child element.
-->
<!ATTLIST entry key-ref CDATA #IMPLIED>

<!--
	A short-cut alternative to a child element "value".
-->
<!ATTLIST entry value CDATA #IMPLIED>

<!--
	A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST entry value-ref CDATA #IMPLIED>

<!--
	A key element can contain an inner bean, ref, value, or collection.
-->
<!ELEMENT key (
	(bean | ref | idref | value | null | list | set | map | props)
)>


<!--
	Props elements differ from map elements in that values must be strings.
	Props may be empty.
-->
<!ELEMENT props (
	(prop)*
)>

<!--
	Enable/disable merging for collections when using parent/child beans.
-->
<!ATTLIST props merge (true | false | default) "default">

<!--
	Element content is the string value of the property.
	Note that whitespace is trimmed off to avoid unwanted whitespace
	caused by typical XML formatting.
-->
<!ELEMENT prop (#PCDATA)>

<!--
	Each property element must specify its key.
-->
<!ATTLIST prop key CDATA #REQUIRED>

